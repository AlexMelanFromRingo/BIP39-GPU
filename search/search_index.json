{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"BIP39 GPU","text":"<p>GPU-accelerated BIP39 mnemonic operations using OpenCL</p> <p> </p>"},{"location":"#what-is-bip39-gpu","title":"What is BIP39 GPU?","text":"<p>BIP39 GPU is a Python library and CLI tool for working with BIP39 mnemonics with GPU acceleration via OpenCL.</p> <p>It supports the full pipeline from mnemonic generation to Bitcoin address derivation \u2014 including all modern address formats \u2014 entirely on the GPU.</p>"},{"location":"#features","title":"Features","text":""},{"location":"#core-bip39","title":"Core BIP39","text":"<ul> <li>Generate mnemonics: 12, 15, 18, 21, or 24 words</li> <li>Validate mnemonics with checksum verification</li> <li>Derive seeds: PBKDF2-HMAC-SHA512, 2048 iterations (BIP39 standard)</li> <li>Cryptographic entropy using <code>secrets.token_bytes()</code></li> </ul>"},{"location":"#gpu-acceleration-opencl","title":"GPU Acceleration (OpenCL)","text":"<ul> <li>SHA-256 and SHA-512 batch hashing</li> <li>PBKDF2-HMAC-SHA512 batch seed derivation</li> <li>secp256k1 elliptic curve operations (point multiplication)</li> <li>RIPEMD-160 hashing</li> <li>Full BIP32 key derivation pipeline on GPU</li> <li>Works with any OpenCL device: NVIDIA, AMD, Intel, or CPU via POCL</li> </ul>"},{"location":"#bitcoin-address-formats","title":"Bitcoin Address Formats","text":"Format Standard Path Prefix P2PKH BIP44 m/44'/0'/0'/0/n <code>1...</code> P2SH-P2WPKH BIP49 m/49'/0'/0'/0/n <code>3...</code> P2WPKH (Native SegWit) BIP84 m/84'/0'/0'/0/n <code>bc1q...</code> P2TR (Taproot) BIP86 m/86'/0'/0'/0/n <code>bc1p...</code>"},{"location":"#brute-force-wallet-recovery","title":"Brute-force / Wallet Recovery","text":"<ul> <li>Pattern-based mnemonic recovery: <code>\"word1 ??? word3 ???\"</code></li> <li>GPU-accelerated checksum validation</li> <li>Optional target address matching</li> </ul>"},{"location":"#quick-install","title":"Quick Install","text":"Bash<pre><code># Download the wheel from GitHub Releases\npip install bip39_gpu-0.1.0-py3-none-any.whl\n</code></pre> <p>Or from source:</p> Bash<pre><code>git clone https://github.com/AlexMelanFromRingo/BIP39-GPU.git\ncd BIP39-GPU &amp;&amp; pip install -e .\n</code></pre> <p>See Installation for full setup including OpenCL runtime.</p>"},{"location":"#quick-example","title":"Quick Example","text":"Python<pre><code>from bip39_gpu import BIP39Mnemonic\nfrom bip39_gpu.gpu.bip32_gpu import batch_seed_to_address\n\n# Generate and validate a mnemonic\nmnemonic = BIP39Mnemonic.generate(12)\nassert BIP39Mnemonic.validate(mnemonic)\n\n# Derive seed\nseed = BIP39Mnemonic.to_seed(mnemonic)\n\n# Derive all 4 address formats via GPU\nfor fmt in [\"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\", \"P2TR\"]:\n    addr = batch_seed_to_address([seed], address_format=fmt, use_gpu=True)[0]\n    print(f\"{fmt:15} {addr}\")\n</code></pre>"},{"location":"#cli","title":"CLI","text":"Bash<pre><code>bip39-gpu generate --words 12\nbip39-gpu validate \"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about\"\nbip39-gpu address \"mnemonic phrase\" --format P2TR --count 5 --gpu\n</code></pre> <p>See CLI Reference for all commands.</p>"},{"location":"addresses/","title":"Bitcoin Address Formats","text":"<p>BIP39 GPU supports all four major Bitcoin address formats derived from a single mnemonic. Each format uses a different BIP derivation path and encoding scheme.</p>"},{"location":"addresses/#overview","title":"Overview","text":"Format BIP Derivation Path Prefix Encoding P2PKH (Legacy) BIP44 m/44'/0'/0'/0/n <code>1...</code> Base58Check P2SH-P2WPKH (SegWit compat.) BIP49 m/49'/0'/0'/0/n <code>3...</code> Base58Check P2WPKH (Native SegWit) BIP84 m/84'/0'/0'/0/n <code>bc1q...</code> Bech32 P2TR (Taproot) BIP86 m/86'/0'/0'/0/n <code>bc1p...</code> Bech32m"},{"location":"addresses/#known-test-vector","title":"Known Test Vector","text":"<p>For the mnemonic <code>abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about</code> (passphrase: <code>\"\"</code>):</p> Format Address P2PKH <code>1LqBGSKuX5yYUonjxT5qGfpUsXKYYWeabA</code> P2SH-P2WPKH <code>37VucYSaXLCAsxYyAPfbSi9eh4iEcbShgf</code> P2WPKH <code>bc1qcr8te4kr609gcawutmrza0j4xv80jy8z306fyu</code> P2TR <code>bc1p5cyxnuxmeuwuvkwfem96lqzszd02n6xdcjrs20cac6yqjjwudpxqkedrcr</code> <p>These match the official BIP84 / BIP49 / BIP86 test vectors.</p>"},{"location":"addresses/#p2pkh-pay-to-public-key-hash-legacy","title":"P2PKH \u2014 Pay to Public Key Hash (Legacy)","text":"<p>Standard: BIP44 Path: <code>m/44'/0'/0'/0/n</code> Encoding: Base58Check with version byte <code>0x00</code></p> Text Only<pre><code>pubkey \u2192 SHA256 \u2192 RIPEMD160 \u2192 Base58Check(0x00 + hash160)\n</code></pre> Python<pre><code>from bip39_gpu.gpu.bip32_gpu import seed_to_address\naddr = seed_to_address(seed, address_format=\"P2PKH\")\n# \u2192 \"1LqBGSKuX5yYUonjxT5qGfpUsXKYYWeabA\"\n</code></pre>"},{"location":"addresses/#p2sh-p2wpkh-segwit-compatibility","title":"P2SH-P2WPKH \u2014 SegWit Compatibility","text":"<p>Standard: BIP49 Path: <code>m/49'/0'/0'/0/n</code> Encoding: Base58Check with version byte <code>0x05</code></p> Text Only<pre><code>pubkey \u2192 hash160 \u2192 redeemScript = OP_0 OP_PUSH20 hash160\n       \u2192 Base58Check(0x05 + hash160(redeemScript))\n</code></pre> <p>This format is SegWit-compatible: spending is done with witness data, but the address looks like a legacy <code>3...</code> address, enabling use with wallets that don't support native SegWit.</p> Python<pre><code>addr = seed_to_address(seed, address_format=\"P2SH_P2WPKH\")\n# \u2192 \"37VucYSaXLCAsxYyAPfbSi9eh4iEcbShgf\"\n</code></pre>"},{"location":"addresses/#p2wpkh-native-segwit","title":"P2WPKH \u2014 Native SegWit","text":"<p>Standard: BIP84 Path: <code>m/84'/0'/0'/0/n</code> Encoding: Bech32 (BIP173), witness version 0</p> Text Only<pre><code>pubkey \u2192 hash160 \u2192 Bech32(\"bc\", 0, hash160)\n</code></pre> Python<pre><code>addr = seed_to_address(seed, address_format=\"P2WPKH\")\n# \u2192 \"bc1qcr8te4kr609gcawutmrza0j4xv80jy8z306fyu\"\n</code></pre> <p>Bech32 uses a GF(2\u2075) BCH checksum with constant <code>1</code>.</p>"},{"location":"addresses/#p2tr-taproot","title":"P2TR \u2014 Taproot","text":"<p>Standard: BIP86 Path: <code>m/86'/0'/0'/0/n</code> Encoding: Bech32m (BIP350), witness version 1</p>"},{"location":"addresses/#key-path-taptweak-bip341","title":"Key-path taptweak (BIP341)","text":"<p>Taproot applies a cryptographic tweak to the public key before encoding:</p> Text Only<pre><code>x_only = pubkey.x  (32 bytes)\nlift_x(P): reconstruct P with even y-coordinate\nt = H_TapTweak(x_only)         # tagged hash (SHA256(SHA256(tag) \u2016 SHA256(tag) \u2016 msg))\nQ = P + t\u00b7G                    # tweaked output key\naddr = Bech32m(\"bc\", 1, Q.x)\n</code></pre> <p>The tagged hash ensures domain separation: Text Only<pre><code>H_TapTweak(msg) = SHA256(SHA256(\"TapTweak\") \u2016 SHA256(\"TapTweak\") \u2016 msg)\n</code></pre></p> Python<pre><code>addr = seed_to_address(seed, address_format=\"P2TR\")\n# \u2192 \"bc1p5cyxnuxmeuwuvkwfem96lqzszd02n6xdcjrs20cac6yqjjwudpxqkedrcr\"\n</code></pre>"},{"location":"addresses/#multiple-addresses-from-one-mnemonic","title":"Multiple Addresses from One Mnemonic","text":"<p>The <code>n</code> index in the derivation path gives you multiple addresses from the same mnemonic:</p> Python<pre><code>from bip39_gpu import BIP39Mnemonic\nfrom bip39_gpu.gpu.bip32_gpu import _bip_derive_cpu, pubkey_to_p2tr, hash160_to_p2wpkh\nimport hashlib\n\nmnemonic = \"abandon \" * 11 + \"about\"\nseed = BIP39Mnemonic.to_seed(mnemonic.strip())\n\nfor index in range(5):\n    privkey, pubkey = _bip_derive_cpu(seed, purpose=84, coin_type=0, address_index=index)\n    # Compute hash160\n    sha = hashlib.sha256(pubkey).digest()\n    ripemd = hashlib.new(\"ripemd160\", sha).digest()\n    addr = hash160_to_p2wpkh(ripemd)\n    print(f\"m/84'/0'/0'/0/{index}  {addr}\")\n</code></pre>"},{"location":"addresses/#testnet-addresses","title":"Testnet Addresses","text":"<p>Pass <code>mainnet=False</code> to get testnet addresses:</p> Python<pre><code>addr = seed_to_address(seed, address_format=\"P2WPKH\", mainnet=False)\n# \u2192 \"tb1q...\"\n</code></pre> Format Mainnet prefix Testnet prefix P2PKH <code>1...</code> <code>m...</code> or <code>n...</code> P2SH-P2WPKH <code>3...</code> <code>2...</code> P2WPKH <code>bc1q...</code> <code>tb1q...</code> P2TR <code>bc1p...</code> <code>tb1p...</code>"},{"location":"api/","title":"Python API","text":""},{"location":"api/#bip39mnemonic","title":"<code>BIP39Mnemonic</code>","text":"<p>Main class for BIP39 operations.</p> Python<pre><code>from bip39_gpu import BIP39Mnemonic\n</code></pre>"},{"location":"api/#bip39mnemonicgeneratewords12","title":"<code>BIP39Mnemonic.generate(words=12)</code>","text":"<p>Generate a cryptographically secure random mnemonic.</p> Python<pre><code>mnemonic = BIP39Mnemonic.generate(12)   # 12 words\nmnemonic = BIP39Mnemonic.generate(24)   # 24 words\n</code></pre> Parameter Type Default Description <code>words</code> <code>int</code> <code>12</code> Word count: 12, 15, 18, 21, or 24 <p>Returns: <code>str</code> \u2014 space-separated mnemonic phrase</p> <p>Notes: Uses <code>secrets.token_bytes()</code> for entropy. Never uses <code>random</code> module.</p>"},{"location":"api/#bip39mnemonicvalidatemnemonic","title":"<code>BIP39Mnemonic.validate(mnemonic)</code>","text":"<p>Validate a mnemonic phrase (word list + checksum).</p> Python<pre><code>ok = BIP39Mnemonic.validate(\"abandon abandon ... about\")   # True\nok = BIP39Mnemonic.validate(\"invalid phrase\")              # False\n</code></pre> <p>Returns: <code>bool</code></p>"},{"location":"api/#bip39mnemonicto_seedmnemonic-passphrase","title":"<code>BIP39Mnemonic.to_seed(mnemonic, passphrase=\"\")</code>","text":"<p>Derive a 64-byte seed using PBKDF2-HMAC-SHA512 (BIP39 standard).</p> Python<pre><code>seed = BIP39Mnemonic.to_seed(mnemonic)\nseed = BIP39Mnemonic.to_seed(mnemonic, passphrase=\"my passphrase\")\nassert len(seed) == 64\n</code></pre> Parameter Type Default Description <code>mnemonic</code> <code>str</code> \u2014 BIP39 mnemonic phrase <code>passphrase</code> <code>str</code> <code>\"\"</code> Optional BIP39 passphrase <p>Returns: <code>bytes</code> (64 bytes)</p>"},{"location":"api/#address-derivation","title":"Address Derivation","text":"Python<pre><code>from bip39_gpu.gpu.bip32_gpu import seed_to_address, batch_seed_to_address\n</code></pre>"},{"location":"api/#seed_to_addressseed-address_formatp2pkh-mainnettrue-use_gputrue","title":"<code>seed_to_address(seed, address_format=\"P2PKH\", mainnet=True, use_gpu=True)</code>","text":"<p>Derive a single Bitcoin address from a seed.</p> Python<pre><code>from bip39_gpu.gpu.bip32_gpu import seed_to_address\n\nseed = BIP39Mnemonic.to_seed(mnemonic)\n\np2pkh  = seed_to_address(seed, address_format=\"P2PKH\")\np2sh   = seed_to_address(seed, address_format=\"P2SH_P2WPKH\")\np2wpkh = seed_to_address(seed, address_format=\"P2WPKH\")\np2tr   = seed_to_address(seed, address_format=\"P2TR\")\n</code></pre> Parameter Type Default Description <code>seed</code> <code>bytes</code> \u2014 64-byte BIP39 seed <code>address_format</code> <code>str</code> <code>\"P2PKH\"</code> One of: <code>P2PKH</code>, <code>P2SH_P2WPKH</code>, <code>P2WPKH</code>, <code>P2TR</code> <code>mainnet</code> <code>bool</code> <code>True</code> <code>False</code> for testnet <code>use_gpu</code> <code>bool</code> <code>True</code> Use GPU if available, fall back to CPU <p>Returns: <code>str</code> \u2014 Bitcoin address</p>"},{"location":"api/#batch_seed_to_addressseeds-address_formatp2pkh-mainnettrue-use_gputrue","title":"<code>batch_seed_to_address(seeds, address_format=\"P2PKH\", mainnet=True, use_gpu=True)</code>","text":"<p>Derive addresses for a batch of seeds. GPU-accelerated when available.</p> Python<pre><code>from bip39_gpu.gpu.bip32_gpu import batch_seed_to_address\n\nseeds = [BIP39Mnemonic.to_seed(m) for m in mnemonics]\naddresses = batch_seed_to_address(seeds, address_format=\"P2WPKH\", use_gpu=True)\n</code></pre> Parameter Type Default Description <code>seeds</code> <code>list[bytes]</code> \u2014 List of 64-byte seeds <code>address_format</code> <code>str</code> <code>\"P2PKH\"</code> Address format <code>mainnet</code> <code>bool</code> <code>True</code> <code>False</code> for testnet <code>use_gpu</code> <code>bool</code> <code>True</code> Use GPU batch processing <p>Returns: <code>list[str]</code> \u2014 addresses in the same order as <code>seeds</code></p>"},{"location":"api/#batch-pbkdf2","title":"Batch PBKDF2","text":"Python<pre><code>from bip39_gpu.core.pbkdf2_batch import batch_pbkdf2_cpu\n</code></pre>"},{"location":"api/#batch_pbkdf2_cpumnemonics-passphrase","title":"<code>batch_pbkdf2_cpu(mnemonics, passphrase=\"\")</code>","text":"<p>Derive seeds for multiple mnemonics using CPU (multi-threaded).</p> Python<pre><code>seeds = batch_pbkdf2_cpu([\"mnemonic1\", \"mnemonic2\"], passphrase=\"\")\n</code></pre> <p>Returns: <code>list[bytes]</code></p>"},{"location":"api/#gpu-context","title":"GPU Context","text":"Python<pre><code>from bip39_gpu.gpu.context import get_gpu_context\n\nctx = get_gpu_context()\nif ctx:\n    print(f\"GPU: {ctx.devices[0].name}\")\nelse:\n    print(\"No OpenCL device found, using CPU fallback\")\n</code></pre>"},{"location":"api/#exceptions","title":"Exceptions","text":"Python<pre><code>from bip39_gpu.utils.exceptions import (\n    BIP39Error,           # Base exception\n    InvalidMnemonic,      # Invalid words or checksum\n    InvalidWordCount,     # Word count not in {12,15,18,21,24}\n    InvalidEntropySize,   # Entropy bits not in {128,160,192,224,256}\n    GPUNotAvailable,      # OpenCL not found (non-fatal, falls back to CPU)\n)\n</code></pre>"},{"location":"api/#complete-example","title":"Complete Example","text":"Python<pre><code>from bip39_gpu import BIP39Mnemonic\nfrom bip39_gpu.gpu.bip32_gpu import batch_seed_to_address\nfrom bip39_gpu.utils.exceptions import InvalidMnemonic\n\nBATCH = 32\n\n# Generate batch\nmnemonics = [BIP39Mnemonic.generate(12) for _ in range(BATCH)]\n\n# Validate all\nfor m in mnemonics:\n    assert BIP39Mnemonic.validate(m), f\"Invalid: {m}\"\n\n# Derive seeds\nseeds = [BIP39Mnemonic.to_seed(m) for m in mnemonics]\n\n# Derive all 4 address formats in batch\nfor fmt in [\"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\", \"P2TR\"]:\n    addrs = batch_seed_to_address(seeds, address_format=fmt, use_gpu=True)\n    print(f\"\\n{fmt}:\")\n    for m, a in zip(mnemonics[:3], addrs[:3]):\n        print(f\"  {m[:40]}...  {a}\")\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v010-2026-02-17","title":"v0.1.0 \u2014 2026-02-17","text":"<p>Initial public release.</p>"},{"location":"changelog/#added","title":"Added","text":"<p>Core BIP39 - Mnemonic generation (12 / 15 / 18 / 21 / 24 words) using <code>secrets.token_bytes()</code> - Mnemonic validation with SHA-256 checksum verification - Seed derivation: PBKDF2-HMAC-SHA512, 2048 iterations (BIP39 standard) - Python library API: <code>BIP39Mnemonic.generate()</code>, <code>.validate()</code>, <code>.to_seed()</code></p> <p>GPU Acceleration (OpenCL) - SHA-256 batch hashing on GPU - SHA-512 batch hashing on GPU - PBKDF2-HMAC-SHA512 batch seed derivation on GPU - secp256k1 elliptic curve point multiplication on GPU (Jacobian coordinates) - RIPEMD-160 on GPU - Full BIP32 HD key derivation pipeline on GPU (hardened + non-hardened) - Graceful CPU fallback when OpenCL is unavailable - POCL 5.0 support (CPU-based OpenCL)</p> <p>Bitcoin Address Formats - P2PKH \u2014 BIP44 path <code>m/44'/0'/0'/0/n</code> \u2014 <code>1...</code> - P2SH-P2WPKH \u2014 BIP49 path <code>m/49'/0'/0'/0/n</code> \u2014 <code>3...</code> - P2WPKH (Native SegWit) \u2014 BIP84 path <code>m/84'/0'/0'/0/n</code> \u2014 <code>bc1q...</code> - P2TR (Taproot) \u2014 BIP86 path <code>m/86'/0'/0'/0/n</code> \u2014 <code>bc1p...</code> - Bech32 encoder (BIP173) implemented from scratch - Bech32m encoder (BIP350) for Taproot - BIP341 Taproot key-path tweak with BIP340 tagged hash</p> <p>CLI - <code>bip39-gpu generate</code> \u2014 generate mnemonics - <code>bip39-gpu validate</code> \u2014 validate mnemonics - <code>bip39-gpu seed</code> \u2014 derive seeds - <code>bip39-gpu address</code> \u2014 derive Bitcoin addresses (all 4 formats) - <code>bip39-gpu bruteforce</code> \u2014 pattern-based wallet recovery</p> <p>Brute-force / Recovery - Pattern syntax: <code>\"word1 ??? word3\"</code> (??? = unknown word) - GPU-accelerated checksum validation - Optional target address matching</p> <p>Testing - 128 tests (4 skipped without GPU) - Verified against official BIP39 / BIP84 / BIP49 / BIP86 test vectors - secp256k1 aliasing bug fixed (<code>jac_dbl</code> and <code>jac_add_affine</code> in-place safety)</p>"},{"location":"changelog/#known-limitations","title":"Known Limitations","text":"<ul> <li>OpenCL kernel compilation may be slow on first run (results are cached by driver)</li> <li>PBKDF2 GPU implementation is optimized for batch sizes \u2265 16</li> <li>Brute-force with 3+ unknown words is computationally infeasible</li> </ul>"},{"location":"changelog/#dependencies","title":"Dependencies","text":"<ul> <li>Python 3.12+</li> <li>pyopencl \u2265 2024.1</li> <li>numpy \u2265 1.26.0</li> <li>click \u2265 8.1.0</li> <li>cryptography \u2265 42.0.0</li> <li>bip-utils \u2265 2.9.0</li> </ul>"},{"location":"cli/","title":"CLI Reference","text":"<p>The <code>bip39-gpu</code> CLI provides commands for mnemonic generation, validation, seed derivation, address generation, and wallet recovery.</p>"},{"location":"cli/#global-options","title":"Global Options","text":"Text Only<pre><code>bip39-gpu [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --version  Show the version and exit.\n  --help     Show this message and exit.\n</code></pre>"},{"location":"cli/#generate","title":"<code>generate</code>","text":"<p>Generate BIP39 mnemonics.</p> Bash<pre><code>bip39-gpu generate [OPTIONS]\n</code></pre> Option Default Description <code>--words</code> <code>12</code> Number of words: 12, 15, 18, 21, 24 <code>--count</code> <code>1</code> Number of mnemonics to generate <code>--json</code> <code>false</code> Output as JSON <p>Examples:</p> Bash<pre><code># Generate a 12-word mnemonic\nbip39-gpu generate\n\n# Generate a 24-word mnemonic\nbip39-gpu generate --words 24\n\n# Generate 10 mnemonics\nbip39-gpu generate --count 10\n\n# JSON output\nbip39-gpu generate --words 12 --count 3 --json\n</code></pre>"},{"location":"cli/#validate","title":"<code>validate</code>","text":"<p>Validate a BIP39 mnemonic (word list and checksum).</p> Bash<pre><code>bip39-gpu validate MNEMONIC\n</code></pre> Argument Description <code>MNEMONIC</code> The mnemonic phrase to validate (quoted) <p>Examples:</p> Bash<pre><code>bip39-gpu validate \"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about\"\n# \u2713 Valid mnemonic (12 words, checksum OK)\n\nbip39-gpu validate \"wrong word list\"\n# \u2717 Invalid mnemonic: word 'wrong' not in BIP39 wordlist\n</code></pre>"},{"location":"cli/#seed","title":"<code>seed</code>","text":"<p>Derive a 64-byte seed from a mnemonic using PBKDF2-HMAC-SHA512.</p> Bash<pre><code>bip39-gpu seed MNEMONIC [OPTIONS]\n</code></pre> Option Default Description <code>--passphrase</code> <code>\"\"</code> Optional passphrase (BIP39 extension) <code>--gpu</code> <code>false</code> Use GPU for PBKDF2 computation <code>--json</code> <code>false</code> Output as JSON <p>Examples:</p> Bash<pre><code>bip39-gpu seed \"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about\"\n# Seed: c55257e96a...\n\nbip39-gpu seed \"my mnemonic\" --passphrase \"my secret\"\nbip39-gpu seed \"my mnemonic\" --gpu --json\n</code></pre>"},{"location":"cli/#address","title":"<code>address</code>","text":"<p>Derive Bitcoin addresses from a mnemonic.</p> Bash<pre><code>bip39-gpu address MNEMONIC [OPTIONS]\n</code></pre> Option Default Description <code>--format</code> <code>P2PKH</code> Address format: <code>P2PKH</code>, <code>P2SH_P2WPKH</code>, <code>P2WPKH</code>, <code>P2TR</code> <code>--count</code> <code>1</code> Number of addresses to derive <code>--passphrase</code> <code>\"\"</code> Optional passphrase <code>--gpu</code> <code>false</code> Use GPU for derivation <code>--json</code> <code>false</code> Output as JSON <p>Address formats:</p> Format BIP Path Prefix <code>P2PKH</code> BIP44 m/44'/0'/0'/0/n <code>1...</code> <code>P2SH_P2WPKH</code> BIP49 m/49'/0'/0'/0/n <code>3...</code> <code>P2WPKH</code> BIP84 m/84'/0'/0'/0/n <code>bc1q...</code> <code>P2TR</code> BIP86 m/86'/0'/0'/0/n <code>bc1p...</code> <p>Examples:</p> Bash<pre><code># Legacy address (default)\nbip39-gpu address \"my mnemonic\"\n\n# Taproot address\nbip39-gpu address \"my mnemonic\" --format P2TR\n\n# First 10 Native SegWit addresses\nbip39-gpu address \"my mnemonic\" --format P2WPKH --count 10\n\n# All formats, GPU-accelerated\nbip39-gpu address \"my mnemonic\" --format P2PKH --gpu\nbip39-gpu address \"my mnemonic\" --format P2SH_P2WPKH --gpu\nbip39-gpu address \"my mnemonic\" --format P2WPKH --gpu\nbip39-gpu address \"my mnemonic\" --format P2TR --gpu\n</code></pre>"},{"location":"cli/#bruteforce","title":"<code>bruteforce</code>","text":"<p>Recover a mnemonic by brute-forcing unknown words.</p> Bash<pre><code>bip39-gpu bruteforce [OPTIONS]\n</code></pre> Option Required Description <code>--pattern</code> Yes Mnemonic pattern with <code>???</code> for unknown words <code>--target</code> No Target Bitcoin address to match <code>--format</code> No Address format for target matching (default: <code>P2PKH</code>) <code>--gpu</code> No Use GPU for validation (recommended) <code>--json</code> No Output as JSON <p>Pattern syntax: - Known word: write the word - Unknown word: use <code>???</code></p> <p>Examples:</p> Bash<pre><code># 1 unknown word (2,048 combinations)\nbip39-gpu bruteforce \\\n  --pattern \"abandon ??? abandon abandon abandon abandon abandon abandon abandon abandon abandon about\" \\\n  --gpu\n\n# 2 unknown words with target address\nbip39-gpu bruteforce \\\n  --pattern \"word1 word2 ??? word4 word5 word6 word7 word8 word9 word10 word11 ???\" \\\n  --target 1A1zP1eP5QGefi2DMPTfTL5SLmv7Divf \\\n  --format P2PKH \\\n  --gpu\n</code></pre> <p>Warning</p> <p>Each additional <code>???</code> multiplies the search space by 2,048. Three or more unknown words may be computationally infeasible.</p>"},{"location":"gpu/","title":"GPU Acceleration","text":"<p>BIP39 GPU uses OpenCL to accelerate cryptographic operations. This page explains how the GPU pipeline works, how to set it up, and what to expect.</p>"},{"location":"gpu/#how-it-works","title":"How It Works","text":"<p>The library implements the following operations directly in OpenCL C kernels:</p> Operation Kernel file Used in SHA-256 <code>gpu/cl/sha256.cl</code> Checksum, BIP32 HMAC SHA-512 <code>gpu/cl/sha512.cl</code> PBKDF2, HMAC-SHA512 PBKDF2-HMAC-SHA512 <code>gpu/cl/pbkdf2_hmac_sha512.cl</code> Seed derivation secp256k1 <code>gpu/cl/secp256k1.cl</code> Public key generation, BIP32 child keys RIPEMD-160 <code>gpu/cl/ripemd160.cl</code> Bitcoin hash160 BIP32 derivation <code>gpu/cl/bip32.cl</code> Full HD key derivation <p>All operations are implemented in Jacobian coordinates for secp256k1 with full aliasing safety.</p>"},{"location":"gpu/#pocl-cpu-opencl","title":"POCL \u2014 CPU OpenCL","text":"<p>If you don't have a dedicated GPU, POCL provides an OpenCL implementation that runs on your CPU. It works seamlessly and enables GPU code testing without any hardware.</p> Bash<pre><code># Ubuntu / Debian\nsudo apt install pocl-opencl-icd ocl-icd-opencl-dev\n</code></pre> <p>POCL 5.0 is supported and tested.</p>"},{"location":"gpu/#check-gpu-availability","title":"Check GPU Availability","text":"Python<pre><code>import pyopencl as cl\n\nplatforms = cl.get_platforms()\nfor p in platforms:\n    print(f\"Platform: {p.name}\")\n    for d in p.get_devices():\n        print(f\"  {d.name}  ({cl.device_type.to_string(d.type)})\")\n</code></pre> Python<pre><code>from bip39_gpu.gpu.context import get_gpu_context\n\nctx = get_gpu_context()\nprint(\"GPU available:\", ctx is not None)\nif ctx:\n    print(\"Device:\", ctx.devices[0].name)\n</code></pre>"},{"location":"gpu/#gpu-vs-cpu-fallback","title":"GPU vs CPU Fallback","text":"<p>All GPU functions gracefully fall back to CPU if OpenCL is unavailable:</p> Python<pre><code>from bip39_gpu.gpu.bip32_gpu import batch_seed_to_address\n\n# use_gpu=True tries GPU first, falls back to CPU silently\naddresses = batch_seed_to_address(seeds, use_gpu=True)\n\n# Force CPU\naddresses = batch_seed_to_address(seeds, use_gpu=False)\n</code></pre>"},{"location":"gpu/#bip32-gpu-pipeline","title":"BIP32 GPU Pipeline","text":"<p>The full address derivation pipeline runs on GPU:</p> Text Only<pre><code>Seed (64 bytes)\n    \u2502\n    \u25bc\nMaster key derivation (HMAC-SHA512)\n    \u2502\n    \u25bc\nHardened child: m/purpose'/coin_type'/0'  (HMAC-SHA512)\n    \u2502\n    \u25bc\nNon-hardened child: /0/index  (HMAC-SHA512 + secp256k1 point add)\n    \u2502\n    \u25bc\nPublic key compression (secp256k1)\n    \u2502\n    \u25bc\nhash160 = RIPEMD-160(SHA-256(pubkey))\n    \u2502\n    \u251c\u2500\u25b6 P2PKH:      Base58Check(0x00 + hash160)\n    \u251c\u2500\u25b6 P2SH-P2WPKH: Base58Check(0x05 + hash160(redeemScript))\n    \u251c\u2500\u25b6 P2WPKH:     Bech32(0, hash160)\n    \u2514\u2500\u25b6 P2TR:       Bech32m(1, taptweak(pubkey).x)\n</code></pre> <p>The kernel <code>bip32_seed_to_hash160</code> runs this entire pipeline per seed, outputting <code>hash160</code>, <code>privkey</code>, and <code>pubkey</code> for each input.</p>"},{"location":"gpu/#batch-processing","title":"Batch Processing","text":"<p>The GPU pipeline processes many seeds in parallel. Recommended batch sizes:</p> Device Recommended batch size CPU (POCL) 16\u201364 Entry GPU (GTX 1060 / RX 580) 256\u20131024 High-end GPU (RTX 3090 / RX 6900) 1024\u20138192 Python<pre><code>BATCH = 64\nseeds = [BIP39Mnemonic.to_seed(BIP39Mnemonic.generate(12)) for _ in range(BATCH)]\naddresses = batch_seed_to_address(seeds, address_format=\"P2WPKH\", use_gpu=True)\n</code></pre>"},{"location":"gpu/#secp256k1-implementation-notes","title":"secp256k1 Implementation Notes","text":"<p>The OpenCL secp256k1 implementation uses:</p> <ul> <li>Jacobian coordinates for point doubling and addition (avoids expensive modular inversion)</li> <li>Double-and-add algorithm for scalar multiplication</li> <li>Aliasing-safe operations: Z computed before Y in <code>jac_dbl</code>; <code>2*Y1*J</code> read before <code>ry</code> is   overwritten in <code>jac_add_affine</code></li> <li>256-bit field arithmetic with 8\u00d732-bit limbs in little-endian order</li> </ul> <p>The curve parameters: Text Only<pre><code>p  = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F\nn  = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\nGx = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798\nGy = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8\n</code></pre></p>"},{"location":"gpu/#troubleshooting","title":"Troubleshooting","text":"<p>\"No OpenCL platform found\" Bash<pre><code>sudo apt install pocl-opencl-icd ocl-icd-opencl-dev\n</code></pre></p> <p>GPU results differ from CPU</p> <p>This can happen due to secp256k1 aliasing bugs. The implementation has been tested against BIP39 test vectors. If you suspect an issue, report it on GitHub Issues.</p> <p>OpenCL build failure</p> <p>Enable verbose OpenCL compiler output: Python<pre><code>import os\nos.environ[\"PYOPENCL_COMPILER_OUTPUT\"] = \"1\"\n</code></pre></p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.12+</li> <li>OpenCL runtime (for GPU features)</li> </ul>"},{"location":"installation/#install-the-package","title":"Install the Package","text":""},{"location":"installation/#from-github-releases-recommended","title":"From GitHub Releases (recommended)","text":"<p>Download the latest wheel from GitHub Releases:</p> Bash<pre><code>pip install bip39_gpu-0.1.0-py3-none-any.whl\n</code></pre>"},{"location":"installation/#from-source","title":"From Source","text":"Bash<pre><code>git clone https://github.com/AlexMelanFromRingo/BIP39-GPU.git\ncd BIP39-GPU\npip install -e .\n</code></pre>"},{"location":"installation/#development-setup","title":"Development Setup","text":"Bash<pre><code>git clone https://github.com/AlexMelanFromRingo/BIP39-GPU.git\ncd BIP39-GPU\npython -m venv venv\nsource venv/bin/activate        # Windows: venv\\Scripts\\activate\npip install -e \".[dev]\"\n</code></pre>"},{"location":"installation/#opencl-runtime","title":"OpenCL Runtime","text":"<p>GPU features require an OpenCL runtime. Choose the one matching your hardware:</p> POCL (CPU, any platform)NVIDIA GPUAMD GPUIntel GPU / CPU <p>POCL is a portable OpenCL implementation that runs on your CPU. It requires no GPU and works on Linux, macOS, and Windows (WSL2).</p> <p>Ubuntu / Debian: Bash<pre><code>sudo apt install pocl-opencl-icd ocl-icd-opencl-dev\n</code></pre></p> <p>macOS (Homebrew): Bash<pre><code>brew install pocl\n</code></pre></p> <p>Install the CUDA Toolkit which includes OpenCL support:</p> Bash<pre><code># Ubuntu\nsudo apt install nvidia-opencl-dev\n</code></pre> <p>Install ROCm or the AMD GPU drivers:</p> Bash<pre><code># Ubuntu\nsudo apt install rocm-opencl-runtime\n</code></pre> <p>Install Intel oneAPI or the OpenCL ICD loader:</p> Bash<pre><code>sudo apt install intel-opencl-icd\n</code></pre>"},{"location":"installation/#verify-opencl","title":"Verify OpenCL","text":"<p>After installing a runtime, verify it works:</p> Bash<pre><code>python -c \"\nimport pyopencl as cl\nplatforms = cl.get_platforms()\nfor p in platforms:\n    print(f'Platform: {p.name}')\n    for d in p.get_devices():\n        print(f'  Device: {d.name}')\n\"\n</code></pre> <p>Or use the CLI:</p> Bash<pre><code>bip39-gpu generate --words 12  # will show GPU: available/unavailable\n</code></pre>"},{"location":"installation/#verify-installation","title":"Verify Installation","text":"Bash<pre><code>bip39-gpu --version\nbip39-gpu generate --words 12\n</code></pre> Python<pre><code>from bip39_gpu import BIP39Mnemonic\nmnemonic = BIP39Mnemonic.generate(12)\nprint(mnemonic)\n</code></pre>"},{"location":"quickstart/","title":"Quick Start","text":""},{"location":"quickstart/#cli-5-minutes","title":"CLI \u2014 5 minutes","text":""},{"location":"quickstart/#generate-a-mnemonic","title":"Generate a mnemonic","text":"Bash<pre><code>bip39-gpu generate --words 12\n# Output:\n# legal winner thank year wave sausage worth useful legal winner thank yellow\n\nbip39-gpu generate --words 24\nbip39-gpu generate --words 12 --count 5   # generate 5 mnemonics\nbip39-gpu generate --words 12 --json      # JSON output\n</code></pre>"},{"location":"quickstart/#validate-a-mnemonic","title":"Validate a mnemonic","text":"Bash<pre><code>bip39-gpu validate \"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about\"\n# \u2713 Valid mnemonic (12 words, checksum OK)\n\nbip39-gpu validate \"abandon abandon abandon abandon\"\n# \u2717 Invalid mnemonic\n</code></pre>"},{"location":"quickstart/#derive-a-seed","title":"Derive a seed","text":"Bash<pre><code>bip39-gpu seed \"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about\"\n# Seed: c55257e...\n\nbip39-gpu seed \"mnemonic\" --passphrase \"my secret\"\nbip39-gpu seed \"mnemonic\" --gpu         # use GPU for PBKDF2\n</code></pre>"},{"location":"quickstart/#derive-bitcoin-addresses","title":"Derive Bitcoin addresses","text":"Bash<pre><code># All 4 formats, first 3 addresses each\nbip39-gpu address \"your mnemonic\" --count 3 --gpu\n\n# Specific format\nbip39-gpu address \"your mnemonic\" --format P2TR --count 5\nbip39-gpu address \"your mnemonic\" --format P2WPKH\nbip39-gpu address \"your mnemonic\" --format P2PKH --json\n</code></pre>"},{"location":"quickstart/#batch-operations","title":"Batch operations","text":"Bash<pre><code># Batch seed derivation from stdin\necho \"mnemonic1\nmnemonic2\nmnemonic3\" | bip39-gpu seed --batch --gpu\n</code></pre>"},{"location":"quickstart/#python-library-5-minutes","title":"Python Library \u2014 5 minutes","text":""},{"location":"quickstart/#basic-usage","title":"Basic usage","text":"Python<pre><code>from bip39_gpu import BIP39Mnemonic\n\n# Generate\nmnemonic = BIP39Mnemonic.generate(12)\nprint(mnemonic)\n\n# Validate\nis_valid = BIP39Mnemonic.validate(mnemonic)\nprint(f\"Valid: {is_valid}\")\n\n# Seed\nseed = BIP39Mnemonic.to_seed(mnemonic)\nprint(f\"Seed length: {len(seed)} bytes\")\n\n# Seed with passphrase\nseed = BIP39Mnemonic.to_seed(mnemonic, passphrase=\"my passphrase\")\n</code></pre>"},{"location":"quickstart/#address-derivation","title":"Address derivation","text":"Python<pre><code>from bip39_gpu import BIP39Mnemonic\nfrom bip39_gpu.gpu.bip32_gpu import seed_to_address, batch_seed_to_address\n\nmnemonic = BIP39Mnemonic.generate(12)\nseed = BIP39Mnemonic.to_seed(mnemonic)\n\n# Single address\np2pkh  = seed_to_address(seed, address_format=\"P2PKH\")\np2wpkh = seed_to_address(seed, address_format=\"P2WPKH\")\np2tr   = seed_to_address(seed, address_format=\"P2TR\")\n\nprint(f\"Legacy:  {p2pkh}\")\nprint(f\"SegWit:  {p2wpkh}\")\nprint(f\"Taproot: {p2tr}\")\n</code></pre>"},{"location":"quickstart/#batch-processing-gpu","title":"Batch processing (GPU)","text":"Python<pre><code>from bip39_gpu import BIP39Mnemonic\nfrom bip39_gpu.gpu.bip32_gpu import batch_seed_to_address\n\n# Generate 100 mnemonics\nmnemonics = [BIP39Mnemonic.generate(12) for _ in range(100)]\nseeds = [BIP39Mnemonic.to_seed(m) for m in mnemonics]\n\n# Derive addresses for all 100 seeds in one GPU batch\naddresses = batch_seed_to_address(seeds, address_format=\"P2WPKH\", use_gpu=True)\n\nfor mnemonic, address in zip(mnemonics, addresses):\n    print(f\"{mnemonic[:40]}...  {address}\")\n</code></pre>"},{"location":"quickstart/#streaming-generation","title":"Streaming generation","text":"Python<pre><code>from bip39_gpu import BIP39Mnemonic\nfrom bip39_gpu.gpu.bip32_gpu import batch_seed_to_address\n\nBATCH = 16\n\nwhile True:\n    mnemonics = [BIP39Mnemonic.generate(12) for _ in range(BATCH)]\n    seeds = [BIP39Mnemonic.to_seed(m) for m in mnemonics]\n\n    p2pkh  = batch_seed_to_address(seeds, address_format=\"P2PKH\",       use_gpu=True)\n    p2tr   = batch_seed_to_address(seeds, address_format=\"P2TR\",        use_gpu=True)\n\n    for i in range(BATCH):\n        print(f\"{mnemonics[i]:&lt;56}  {p2pkh[i]:&lt;34}  {p2tr[i]}\")\n</code></pre>"},{"location":"quickstart/#wallet-recovery-brute-force","title":"Wallet Recovery (Brute-force)","text":"Bash<pre><code># Recover a mnemonic with 1 unknown word\nbip39-gpu bruteforce --pattern \"abandon ??? abandon abandon abandon abandon abandon abandon abandon abandon abandon about\" --gpu\n\n# 2 unknown words (4M combinations)\nbip39-gpu bruteforce --pattern \"??? abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon ???\" --gpu\n\n# Match against a known Bitcoin address\nbip39-gpu bruteforce \\\n  --pattern \"word1 word2 ??? word4 word5 word6 word7 word8 word9 word10 word11 ???\" \\\n  --target 1A1zP1eP5QGefi2DMPTfTL5SLmv7Divf \\\n  --gpu\n</code></pre> <p>Search space grows exponentially</p> <ul> <li>1 unknown word: 2,048 combinations</li> <li>2 unknown words: ~4.2 million combinations</li> <li>3 unknown words: ~8.6 billion combinations \u2014 may take days even on GPU</li> </ul>"}]}